#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
#include<cstring>

using namespace std;
struct Edge{
    int from, to;
};

class TheCitiesAndRoadsDivTwo {
public:
    unsigned int ret;
    int seq[1000];
    int edgeGroup[81], group[81], whichgroup[10];
    int groupnum , edgegroupnum;
    vector<string> map;
    vector<Edge> edgepool;
    void solve(int now, int limit, int low){
        if (now == limit){
            unsigned int tmp = 1;
            bool grid[10][10], vst[10];
            int queue[100], front=0, tail=0;
            memset(grid, false, sizeof(grid));
            memset(vst, false, sizeof(vst));
            bool flag = true;
            for (int i=0; i<limit; i++) {
                tmp*=edgeGroup[seq[i]];
                grid[edgepool[seq[i]].from][edgepool[seq[i]].to] = true;
                grid[edgepool[seq[i]].to][edgepool[seq[i]].from] = true;
            }
            //Find circle.
            vst[edgepool[seq[0]].from]=true;
            queue[tail++] = edgepool[seq[0]].from;
            int last[10]; memset(last, -1, sizeof(last));
            while(tail>front && flag){
                int current = queue[front++];
                for (int i=0; i<groupnum; i++) {
                    if (vst[i] && grid[current][i] && last[current]!=i)
                        flag = false;
                    if (!flag) break;
                    if (!vst[i] && grid[current][i]) {
                        last[i] = current;
                        vst[i] = true;
                        queue[tail++] = i;
                    }
                }
            }
            for (int i=0; i<groupnum; i++)
                if (!vst[i])
                    flag = false;
            if (flag)
                ret+=tmp;
            return;
        }
        for (int i=low; i<edgegroupnum - (limit-(now+1)); i++){
            seq[now] = i;
            solve(now+1, limit, i+1);
        }
    }
    void dfs(int now, int num) {
        whichgroup[now] = num;
        group[num]++;
        for(int i=0; i<map.size(); i++){
            if(map[now][i] == 'Y' && whichgroup[i]==-1) {
                dfs(i, num);
            }
        }
    }
	int find(vector <string> tmp_map) {
	    bool tmp_flag = true;
	    for (int i=0; i<tmp_map.size(); i++)
            if (tmp_map[i] != "NNNNNNNNN")
                tmp_flag = false;
        if (tmp_flag) return 4782969;
	    map = tmp_map;
	    ret = groupnum = edgegroupnum = 0;
        memset(whichgroup, -1, sizeof(whichgroup));
        memset(group, 0, sizeof(group));
        for(int i=0; i<map.size(); i++){
            if(whichgroup[i]==-1) {
                dfs(i,groupnum);
                groupnum++;
            }
        }
        if (groupnum==1) return 1;
        for (int i=0; i<groupnum; i++)
            for(int j=i+1; j<groupnum; j++) {
                edgeGroup[edgegroupnum++] = group[i] * group[j];
                Edge tmp; tmp.from = i; tmp.to=j;
                edgepool.push_back(tmp);
            }
        solve(0, groupnum-1, 0);
        return ret;
	}
};


// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	TheCitiesAndRoadsDivTwo *obj;
	int answer;
	obj = new TheCitiesAndRoadsDivTwo();
	clock_t startTime = clock();
	answer = obj->find(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;

	vector <string> p0;
	int p1;

	{
	// ----- test 0 -----
	string t0[] = {"NN","NN"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 1 -----
	string t0[] = {"NY","YN"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 2 -----
	string t0[] = {"NNNNNNNN", "NNNNNNNY", "NNNNNYYN", "NNNNYNNN", "NNNYNNYN", "NNYNNNNN", "NNYNYNNN", "NYNNNNNN"}
;
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 80;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}

	{
	// ----- test 3 -----
	string t0[] = {"NYNN","YNNN","NNNY","NNYN"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}

	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
